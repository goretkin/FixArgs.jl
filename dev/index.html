<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FixArgs.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://goretkin.gitlab.io/FixArgs.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FixArgs.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Examples-of-Base.Fix2"><span>Examples of <code>Base.Fix2</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Symbolic-computation-and-lazy-evaluation"><span>Symbolic computation and lazy evaluation</span></a></li><li><a class="tocitem" href="#Base.Iterators"><span><code>Base.Iterators</code></span></a></li><li><a class="tocitem" href="#Base.Rational"><span><code>Base.Rational</code></span></a></li><li><a class="tocitem" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments"><span>Fixed-Point Numbers and &quot;static&quot; arguments</span></a></li><li><a class="tocitem" href="#Pure-imaginary-type-and-Base.Complex"><span>Pure-imaginary type and <code>Base.Complex</code></span></a></li><li><a class="tocitem" href="#Faster-set-operations-by-deferring-computation"><span>Faster set operations by deferring computation</span></a></li><li><a class="tocitem" href="#Ergonomics-and-Syntax"><span>Ergonomics and Syntax</span></a></li><li class="toplevel"><a class="tocitem" href="#Philosophy"><span>Philosophy</span></a></li><li><a class="tocitem" href="#Names"><span>Names</span></a></li><li><a class="tocitem" href="#Type-Piracy"><span>Type Piracy</span></a></li><li class="toplevel"><a class="tocitem" href="#More-examples"><span>More examples</span></a></li><li><a class="tocitem" href="#Types-of-geometry-primitives-from-scratch"><span>Types of geometry primitives from scratch</span></a></li><li><a class="tocitem" href="#A-way-to-avoid-naming-a-new-method"><span>A way to avoid naming a new method</span></a></li><li><a class="tocitem" href="#Alternative-to-Base.literal_pow"><span>Alternative to <code>Base.literal_pow</code></span></a></li><li><a class="tocitem" href="#Related-Patterns-and-Possible-Applications:"><span>Related Patterns and Possible Applications:</span></a></li><li class="toplevel"><a class="tocitem" href="#Concerns"><span>Concerns</span></a></li><li class="toplevel"><a class="tocitem" href="#API-and-internals"><span>API and internals</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/goretkin/FixArgs.jl/blob/main/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FixArgs.jl"><a class="docs-heading-anchor" href="#FixArgs.jl">FixArgs.jl</a><a id="FixArgs.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FixArgs.jl" title="Permalink"></a></h1><ul><li><a href="#FixArgs.jl">FixArgs.jl</a></li><li><a href="#Motivation">Motivation</a></li><li><a href="#Introduction">Introduction</a></li><li class="no-marker"><ul><li><a href="#Examples-of-Base.Fix2">Examples of <code>Base.Fix2</code></a></li></ul></li><li><a href="#Symbolic-computation-and-lazy-evaluation">Symbolic computation and lazy evaluation</a></li><li class="no-marker"><ul><li><a href="#Base.Iterators"><code>Base.Iterators</code></a></li><li><a href="#Base.Rational"><code>Base.Rational</code></a></li><li><a href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments">Fixed-Point Numbers and &quot;static&quot; arguments</a></li><li><a href="#Pure-imaginary-type-and-Base.Complex">Pure-imaginary type and <code>Base.Complex</code></a></li><li><a href="#Faster-set-operations-by-deferring-computation">Faster set operations by deferring computation</a></li><li><a href="#Ergonomics-and-Syntax">Ergonomics and Syntax</a></li></ul></li><li><a href="#Philosophy">Philosophy</a></li><li class="no-marker"><ul><li><a href="#Names">Names</a></li><li><a href="#Type-Piracy">Type Piracy</a></li></ul></li><li><a href="#More-examples">More examples</a></li><li class="no-marker"><ul><li><a href="#Types-of-geometry-primitives-from-scratch">Types of geometry primitives from scratch</a></li><li><a href="#A-way-to-avoid-naming-a-new-method">A way to avoid naming a new method</a></li><li><a href="#Alternative-to-Base.literal_pow">Alternative to <code>Base.literal_pow</code></a></li><li><a href="#Related-Patterns-and-Possible-Applications:">Related Patterns and Possible Applications:</a></li><li class="no-marker"><ul><li><a href="#partial-application-with-keyword-arguments">partial application with keyword arguments</a></li><li><a href="#array-of-struct-and-struct-of-array-representations">array-of-struct and struct-of-array representations</a></li><li><a href="#non-standard-evaluation">non-standard evaluation</a></li><li><a href="#nominal-vs-structural-fields">nominal vs structural fields</a></li></ul></li></ul></li><li><a href="#Concerns">Concerns</a></li><li><a href="#API-and-internals">API and internals</a></li></ul><h1 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h1><p>This package began as an exploration in generalizing <code>Base.Fix1</code> and <code>Base.Fix2</code>. These types represent particular forms of functions: <code>x -&gt; f(v, x)</code> and <code>x -&gt; f(x, v)</code> for a given <code>f</code> and <code>v</code>. We&#39;ll pick up that motivation shortly.</p><p>There is a secondary motivation for this package, aligned with the philosophy that <a href="https://martinfowler.com/bliki/TwoHardThings.html">choosing names is hard</a>, and that a long name may be avoided when concepts are further broken down:</p><blockquote><p>If you need underscores, it most likely means that you can work harder to find a better name, or perhaps that you are mixing together two concepts that should be separated.</p></blockquote><p><a href="https://discourse.julialang.org/t/naming-remove-all-underscores-to-matter-what/8549/12">(source)</a></p><p>There are a lot of great names within the Julia ecosystem, and meaning is important:</p><blockquote><p>With multiple dispatch, just as the meaning of a function is important to get consistent, it&#39;s also important to get the meanings of the argument slots consistent when possible.</p></blockquote><p><a href="https://github.com/JuliaLang/julia/pull/34296#issuecomment-575299420">(source)</a></p><p>This package can help to re-use these names and put them together in new ways. Crucially, it relies on parametric types, the same facility that allows <code>Vector{Int64}</code> and <code>Vector{Float32}</code> to be given &quot;orthogonal&quot; names, instead of requiring names that bake together the concept of &quot;vector&quot; and  &quot;element type&quot;.</p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Let&#39;s illustrate <code>Fix1</code> and <code>Fix2</code>. We&#39;ll use the <code>string</code> function in <code>Base</code>, which concatenates the string representations of its arguments:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; string(&quot;first &quot;, &quot;second&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;first second&quot;</code></pre><p>Now, to construct and use the <code>Fix1</code> and <code>Fix2</code> types:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Base: Fix1, Fix2</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f1 = Fix1(string, &quot;one then &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(::Base.Fix1{typeof(string), String}) (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f1(&quot;two&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;one then two&quot;</code></pre><p>The function-call behavior of <code>Fix1(f, bind)</code> is the same as <code>x -&gt; f(bind, x)</code>.</p><p>Similarly,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f2 = Fix2(string, &quot; before two&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(::Base.Fix2{typeof(string), String}) (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f2(&quot;one&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;one before two&quot;</code></pre><p>The function-call behavior of <code>Fix2(f, bind)</code> is the same as <code>x -&gt; f(x, bind)</code>.</p><p>The key point of the <code>Fix1</code> and <code>Fix2</code> types is that methods can dispatch on</p><ol><li>the type of <code>f</code></li><li>the type of <code>bind</code></li><li>the position of <code>bind</code> within the function call</li></ol><p>Dispatch is not tenable with anonymous functions. Let&#39;s illustrate while moving to a more practical example using <code>==</code> instead of <code>string</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f1 = x -&gt; x == 0</code><code class="nohighlight hljs ansi" style="display:block;">#1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f2 = Fix1(==, 0)</code><code class="nohighlight hljs ansi" style="display:block;">(::Base.Fix1{typeof(==), Int64}) (generic function with 1 method)</code></pre><p>Now define the &quot;same&quot; things again:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f3 = x -&gt; x == 0</code><code class="nohighlight hljs ansi" style="display:block;">#3 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f4 = Fix1(==, 0)</code><code class="nohighlight hljs ansi" style="display:block;">(::Base.Fix1{typeof(==), Int64}) (generic function with 1 method)</code></pre><p>The types of both the <code>Fix1</code> values is the same:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(f2) === typeof(f4)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>But each anonymous function definition introduces a new type with an opaque name:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(f1), typeof(f3)</code><code class="nohighlight hljs ansi" style="display:block;">(Main.var&quot;#1#2&quot;, Main.var&quot;#3#4&quot;)</code></pre><p>A new anonymous function is always given a unique type, which allows methods to specialize on the specific anonymous function passed as an argument, but does not &quot;permit&quot; dispatch. To be more accurate, as far as dispatch is concerned, the type of anonymous functions is not special:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo(::typeof(f1)) = &quot;f1&quot;</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo(::typeof(f3)) = &quot;f3&quot;</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo(f1)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;f1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo(f3)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;f3&quot;</code></pre><p>But really we&#39;d like to use a type that is less opaque and furthermore is &quot;structural&quot; in some ways, rather than purely &quot;nominal&quot;.</p><h2 id="Examples-of-Base.Fix2"><a class="docs-heading-anchor" href="#Examples-of-Base.Fix2">Examples of <code>Base.Fix2</code></a><a id="Examples-of-Base.Fix2-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-of-Base.Fix2" title="Permalink"></a></h2><p>Where is it useful to dispatch on these special functions? Because <code>Base</code> <a href="https://github.com/JuliaLang/julia/issues/36554">does not export</a> and <a href="https://github.com/JuliaLang/julia/pull/36094">does not document</a> these types, there aren&#39;t many methods <a href="https://juliahub.com/ui/RepoSearch?q=%3A%3A%28Base%5C.%29%3FFix%5B12%5D&amp;r=true">in the Julia ecosystem</a>.</p><p>But these types are constructed with, for example, <code>==(3)</code> or <code>in([1, 2, 3])</code>. A type like these is useful as a predicate to pass to higher-order functions, e.g. <code>findfirst(==(3), some_array)</code> to find the first element that equals <code>3</code>. Brevity aside, these types are useful to define more efficient methods of generic higher-order functions. For example, take <a href="https://github.com/JuliaLang/julia/blob/1f9e8bdbcf0ded6f1386f9329a284366dbb56120/base/array.jl#L1878-L1879">a specific method of the <code>findfirst</code> function</a>:</p><pre><code class="language-julia hljs">findfirst(p::Union{Fix2{typeof(isequal),Int},Fix2{typeof(==),Int}}, r::OneTo{Int}) =
    1 &lt;= p.x &lt;= r.stop ? p.x : nothing</code></pre><p>The fallback for <code>findfirst</code> (triggered by e.g. <code>findfirst(x-&gt;x==3, 1:10)</code> instead of <code>findfirst(==(3), 1:10)</code>) would produce the same (correct) answer, but the method above will be quicker.</p><p>Dispatching on the <em>structure</em> of the predicate function enables a certain form of symbolic computation.</p><h1 id="Symbolic-computation-and-lazy-evaluation"><a class="docs-heading-anchor" href="#Symbolic-computation-and-lazy-evaluation">Symbolic computation and lazy evaluation</a><a id="Symbolic-computation-and-lazy-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-computation-and-lazy-evaluation" title="Permalink"></a></h1><p>This package provides a generalization of <code>Fix1</code> and <code>Fix2</code> in a few ways:</p><ol><li>A function of any positional arity can be used, and any number of its arguments can be bound, allowing the remaining arguments to be provided later.</li><li>A function can have its keyword arguments bound.</li><li>The function <code>x -&gt; f(x, b)</code> is represented with types:<ul><li>a <a href="@ref"><code>Lambda</code></a> to represent function (<code>args -&gt; body</code>)</li><li>a <a href="@ref"><code>Call</code></a> to represent the function <em>call</em> (<code>f(...)</code>) in the body</li><li>a <a href="@ref"><code>ArgPos</code></a> to represent the <code>x</code> in the body of the lambda function</li></ul></li></ol><p>The third generalization is powerful, because it&#39;s effectively the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>.</p><p>It is worth considering first just <a href="@ref"><code>Call</code></a>, which can serve the purpose of representing a <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">delayed function call evaluation</a>. If you prefer, you may also consider a <a href="https://en.wikipedia.org/wiki/Thunk">thunk</a> <code>() -&gt; foo(1, 2)</code>, which would be a <code>Lambda</code> (with no arguments) <em>and</em> a <code>Call</code> that does not mention any &quot;free variables&quot;.</p><p>If laziness is all that is needed, then defining a Julia anonymous function will do the job. But this package allows an additional benefit since methods can dispatch on details of the lazy call.</p><p>In many domains, new types are introduced to represent this pattern.</p><h2 id="Base.Iterators"><a class="docs-heading-anchor" href="#Base.Iterators"><code>Base.Iterators</code></a><a id="Base.Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Base.Iterators" title="Permalink"></a></h2><p><code>Base.Generator</code> consists of two fields <code>f</code> and <code>iter</code>. This can be taken as a representation of <code>map(f, iter)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; gen = let f = string, iter = 1:10
           @xquote map(f, iter)
       end</code><code class="nohighlight hljs ansi" style="display:block;">Call(Some(map), FrankenTuple((Some(string), Some(1:10)), NamedTuple()))</code></pre><p>It&#39;s certainly less nice to look at than <code>Base.Generator{UnitRange{Int64}, typeof(string)}(string, 1:10)</code>. Better UX / ergonomics are be possible by defining a type alias:</p><pre><code class="language-julia hljs">const MyGenerator{F, I} = FixArgs.Call{Some{typeof(map)}, FixArgs.FrankenTuples.FrankenTuple{Tuple{Some{F}, Some{I}, (), Tuple{}}}</code></pre><p>That is quite unsightly, and there are quite a few internals leaking out. We can use a macro instead:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const MyGenerator{F, I} = @xquoteT map(::F, ::I)</code><code class="nohighlight hljs ansi" style="display:block;">FixArgs.Call{Some{typeof(map)}, FrankenTuples.FrankenTuple{Tuple{Some{F}, Some{I}}, (), Tuple{}}} where {F, I}</code></pre><p>It should be made convenient to defining constructors and <code>show</code> methods that correspond with the type alias.</p><p>To evaluate the call (i.e. &quot;collect the iterator&quot;):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; xeval(gen)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{String}:
 &quot;1&quot;
 &quot;2&quot;
 &quot;3&quot;
 &quot;4&quot;
 &quot;5&quot;
 &quot;6&quot;
 &quot;7&quot;
 &quot;8&quot;
 &quot;9&quot;
 &quot;10&quot;</code></pre><p>This example is actually circular. The evaluation of the <code>map</code> call is done in terms of <code>Generator</code>! The <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/abstractarray.jl#L2328">definition</a>:</p><pre><code class="language-julia hljs">map(f, A) = collect(Generator(f,A))</code></pre><p>Breaking this circularity is possible by defining</p><pre><code class="language-julia hljs">function iterate(gen::(@xquoteT map(::F, ::I))) where F, I
    f = FixArgs.xeval(gen.args[1])  # not the prettiest thing right now...
    iter = FixArgs.xeval(gen.args[2])
    # ...
end</code></pre><p>and might also require a separation of the purposes of <code>collect</code> and <code>map</code>. See <a href="https://github.com/JuliaLang/julia/issues/39628">this issue</a>.</p><p>Many types in <code>Base.Iterators</code> can be seen as lazy calls of existing functions. For example <code>Base.Iterators.Filter(flt, itr)</code> could be replaced with <code>@xquote filter(flt, itr)</code>. <code>Base.Iterators.Filter</code> would be an alias for <code>(@xquoteT filter(::F, ::I)) where {F, I}</code> to enable the existing symbolic computation, <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/iterators.jl#L463">e.g.</a>:</p><pre><code class="language-julia hljs">reverse(f::Filter) = Filter(f.flt, reverse(f.itr))</code></pre><p><code>Base.Iterators.Flatten</code>, which <a href="https://github.com/JuliaLang/julia/blob/ef14131db321f8f5a815dd05a5385b5b27d87d8f/base/iterators.jl#L463">defines a convenience function</a></p><pre><code class="language-julia hljs">flatten(itr) = Flatten(itr)</code></pre><p><em>could</em> be written in terms of a function <code>flatten</code> with no methods. However, it is perhaps better seen as <code>@xquote reduce(vcat, it)</code></p><h2 id="Base.Rational"><a class="docs-heading-anchor" href="#Base.Rational"><code>Base.Rational</code></a><a id="Base.Rational-1"></a><a class="docs-heading-anchor-permalink" href="#Base.Rational" title="Permalink"></a></h2><p>What is <code>Rational</code> but lazy division on integers?</p><pre><code class="language-julia hljs">julia&gt; 1/9 * 3/2 # eager division
0.16666666666666666</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (@xquote 1/9) * (@xquote 3/2)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching *(::FixArgs.Call{Some{typeof(/)}, FrankenTuples.FrankenTuple{Tuple{Some{Int64}, Some{Int64}}, (), Tuple{}}}, ::FixArgs.Call{Some{typeof(/)}, FrankenTuples.FrankenTuple{Tuple{Some{Int64}, Some{Int64}}, (), Tuple{}}})
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/base/operators.jl:655</code></pre><p>Of course, we have to do some more work.</p><pre><code class="language-julia hljs">using Base: divgcd

function Base.:*(
        x::(@xquoteT ::T / ::T),
        y::(@xquoteT ::T / ::T),
        ) where {T}
    xn, yd = divgcd(something(x.args[1]), something(y.args[2]))
    xd, yn = divgcd(something(x.args[2]), something(y.args[1]))
    ret = @xquote $(xn * yn) / $(xd * yd) # TODO use `unsafe_rational` and `checked_mul`
    ret
end</code></pre><p>Now, try again:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = (@xquote 1/9) * (@xquote 3/2)</code><code class="nohighlight hljs ansi" style="display:block;">Call(Some(/), FrankenTuple((Some(1), Some(6)), NamedTuple()))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(xeval, q.args) # make numerator and denominator plainly visible</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 6</code></pre><p>compare with using <code>//</code> to construct a <code>Base.Rational</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1//9 * 3//2</code><code class="nohighlight hljs ansi" style="display:block;">1//6</code></pre><p>Finally, because we have encoded the relationship between this &quot;new&quot; rational type, and <code>/</code>, we can do:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; xeval(q)</code><code class="nohighlight hljs ansi" style="display:block;">0.16666666666666666</code></pre><p>We could define an alias:</p><pre><code class="language-julia hljs">const MyRational{T} = @xquoteT(::T / ::T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FixArgs.Call{Some{typeof(/)}, FrankenTuples.FrankenTuple{Tuple{Some{T}, Some{T}}, (), Tuple{}}} where T</code></pre><p>which would also enforce the same type for both the numerator and denominator, as is the case of <code>Base.Rational</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(MyRational{Int32})</code><code class="nohighlight hljs ansi" style="display:block;">8</code></pre><p>Occasionally, a user might find this to be a limitation, yet they would still like to use some of the generic algorithms that might apply.</p><p>The fields of <code>Base.Rational</code> are <code>num</code> and <code>den</code>. They have to be named since there is nothing else that gives the fields any meaning at all. In our type, however, they can be distinguished by the role they play with respect to the <code>/</code> function.</p><h2 id="Fixed-Point-Numbers-and-&quot;static&quot;-arguments"><a class="docs-heading-anchor" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments">Fixed-Point Numbers and &quot;static&quot; arguments</a><a id="Fixed-Point-Numbers-and-&quot;static&quot;-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-Point-Numbers-and-&quot;static&quot;-arguments" title="Permalink"></a></h2><p>Replacing <code>Rational</code> may be silly, but this approach comes with a benefit: it also generalizes fixed-point numbers. A fixed-point number is just a lazy division with a specified (i.e. &quot;static&quot;) denominator.</p><p>If we have a large array of fixed-point numbers with the same denominator, we certainly do not want to store the denominator repeatedly. Furthermore, we want efficient arithmetic. There is no need to check for a common denominator (let alone find one) if the two denominators are known to be equal at code-generation time.</p><p>There are values that we can &quot;bake in&quot; (see <code>Base.isbitstype</code>) into the type of <code>Call</code> itself!</p><p>Here is an example that models <code>FixedPointNumbers.Fixed{Int8,7}</code> from <a href="https://github.com/JuliaMath/FixedPointNumbers.jl"><code>FixedPointNumbers.jl</code></a>. The macros use the notation <code>V::::S</code> (quadruple colon) to mark an argument <code>V</code> as &quot;static&quot;. Also note the use of <code>$</code> to escape subexpressions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyFixed{Int8, 128} === typeof(MyQ0f7(3))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function Base.:+(a::MyFixed{N,D}, b::MyFixed{N,D})::MyFixed{N,D} where {N, D}
           n = something(a.args[1]) + something(b.args[1])
           return (@xquote $(N(n)) / D::::S)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xeval(MyQ0f7(3) + MyQ0f7(2)) === 5/128</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(MyFixed{Int8, 128})</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(Int8)</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>And the generated code appears to be equivalent between</p><pre><code class="language-julia hljs">using FixedPointNumbers
look_inside_1(x, y) = reinterpret(Fixed{Int8, 7}, Int8(x)) + reinterpret(Fixed{Int8, 7}, Int8(y))</code></pre><p>and</p><pre><code class="language-julia hljs">look_inside_2(x, y) = MyQ0f7(x) + MyQ0f7(y)</code></pre><h2 id="Pure-imaginary-type-and-Base.Complex"><a class="docs-heading-anchor" href="#Pure-imaginary-type-and-Base.Complex">Pure-imaginary type and <code>Base.Complex</code></a><a id="Pure-imaginary-type-and-Base.Complex-1"></a><a class="docs-heading-anchor-permalink" href="#Pure-imaginary-type-and-Base.Complex" title="Permalink"></a></h2><p>Now that we can make some arguments static, we can introduce a meaningful example where the lazy call does not correspond to a valid eager call. You can define a type such that <code>xeval</code> raises <code>MethodError</code> and still represent the computation symbolically. You can define a type <code>A</code> in terms of a function <code>f</code> and a type <code>B</code> even if it may not make sense to define a new method of <code>f</code> on <code>B</code>.</p><p>Here is an over-the-top example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct ImaginaryUnit end    # if we want to be really cute, can do `@xquote sqrt((-1)::::S)`</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const Imaginary{T} = @xquoteT ::T * ::ImaginaryUnit</code><code class="nohighlight hljs ansi" style="display:block;">FixArgs.Call{Some{typeof(*)}, FrankenTuples.FrankenTuple{Tuple{Some{T}, Some{Main.ImaginaryUnit}}, (), Tuple{}}} where T</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Imaginary(x) = @xquote x * $(ImaginaryUnit())   # note escaping</code><code class="nohighlight hljs ansi" style="display:block;">FixArgs.Call{Some{typeof(*)}, FrankenTuples.FrankenTuple{Tuple{Some{T}, Some{Main.ImaginaryUnit}}, (), Tuple{}}} where T</code></pre><p>note that if we assume we have no <code>Base.Complex</code> or anything like it, we don&#39;t have a way to further evaluate:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; xeval(Imaginary(3))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching *(::Int64, ::Main.ImaginaryUnit)
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/base/operators.jl:655
  *(::T, !Matched::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/base/int.jl:88
  *(::Union{Int16, Int32, Int64, Int8}, !Matched::BigInt) at /opt/hostedtoolcache/julia/1.7.3/x64/share/julia/base/gmp.jl:542
  ...</code></pre><p>We represented pure imaginary numbers as lazy multiplication of numbers and a singleton type <code>ImaginaryUnit</code>, and it is basically as if we had defined</p><pre><code class="nohighlight hljs">struct Imaginary{T}
    _::T
end</code></pre><p>Let&#39;s just go ahead and represent complex numbers too:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # const MyComplex{R, I} = @xquoteT ::R + (::I * ::ImaginaryUnit) # TODO this macro doesn&#39;t work
       MyComplex(r, i) = @xquote r + i * $(ImaginaryUnit())</code><code class="nohighlight hljs ansi" style="display:block;">MyComplex (generic function with 1 method)</code></pre><p>Note this monster of a type has the same size as <code>Base.Complex</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(Complex(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(MyComplex(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">16</code></pre><p>and the same layout too:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reinterpret(Int64, [Complex(1, 2)])</code><code class="nohighlight hljs ansi" style="display:block;">2-element reinterpret(Int64, ::Vector{Complex{Int64}}):
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reinterpret(Int64, [MyComplex(1, 2)])</code><code class="nohighlight hljs ansi" style="display:block;">2-element reinterpret(Int64, ::Vector{FixArgs.Call{Some{typeof(+)}, FrankenTuples.FrankenTuple{Tuple{Some{Int64}, FixArgs.Call{Some{typeof(*)}, FrankenTuples.FrankenTuple{Tuple{Some{Int64}, Some{Main.ImaginaryUnit}}, (), Tuple{}}}}, (), Tuple{}}}}):
 1
 2</code></pre><p>Of course, there are many different types that would all be mathematically equivalent by swapping the arguments to <code>+</code> or <code>*</code>. Note that swapping the arguments to <code>+</code> would give a different memory layout.</p><h2 id="Faster-set-operations-by-deferring-computation"><a class="docs-heading-anchor" href="#Faster-set-operations-by-deferring-computation">Faster set operations by deferring computation</a><a id="Faster-set-operations-by-deferring-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Faster-set-operations-by-deferring-computation" title="Permalink"></a></h2><p>Suppose we have some generic function to return bounds on set-like objects.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;Produce the unique best bound, in the sense that `x ∈ input` implies `x ∈ result`&quot;&quot;&quot;
function bounding#=(result_type, input)=# end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.bounding</code></pre><p>The objects may be shapes in space, and <code>result_type</code> could correspond to important categories of bounding volumes. To keep things simple, let us deal with sets of integers as represented by e.g. <code>Vector</code> and <code>UnitRange</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bounding(::Type{UnitRange}, v::Vector{&lt;:Integer}) = UnitRange(extrema(v)...)</code><code class="nohighlight hljs ansi" style="display:block;">bounding (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bounding(UnitRange, [1, 3, 5])</code><code class="nohighlight hljs ansi" style="display:block;">1:5</code></pre><p>Consider the following computation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eager = bounding(UnitRange, union(1:3, 5:7))</code><code class="nohighlight hljs ansi" style="display:block;">1:7</code></pre><p>It might be worth deferring that <code>union</code> call. It produces a representation with a size linear in the number of elements, whereas a deferred computation is  representable in constant size.</p><pre><code class="language-julia hljs">using FixArgs

function bounding(
        ::Type{UnitRange},
        _union::(@xquoteT union(::UnitRange{T}, ::UnitRange{T}))
        ) where T &lt;: Integer
    (a, b) = something.(_union.args)
    UnitRange(min(minimum(a), minimum(b)), max(maximum(a), maximum(b)))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">bounding (generic function with 2 methods)</code></pre><p>Now to use our specialized method for bounding unions of <code>UnitRanges</code>, we simply defer one part of the previous computation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lazy = bounding(UnitRange, @xquote union($(1:3),$(5:7)))</code><code class="nohighlight hljs ansi" style="display:block;">1:7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eager == lazy</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Ergonomics-and-Syntax"><a class="docs-heading-anchor" href="#Ergonomics-and-Syntax">Ergonomics and Syntax</a><a id="Ergonomics-and-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Ergonomics-and-Syntax" title="Permalink"></a></h2><p>Ideally, this package would support exactly the syntax that Julia supports. However, it is a bit challenging not being able to hook into lowering exactly.</p><ul><li><a href="https://docs.julialang.org/en/v1/devdocs/ast/#Bracketed-forms">https://docs.julialang.org/en/v1/devdocs/ast/#Bracketed-forms</a></li><li><a href="https://github.com/JuliaLang/julia/pull/32201">https://github.com/JuliaLang/julia/pull/32201</a></li></ul><p>Anonymous function syntax is still under discussion:</p><ul><li><a href="https://github.com/JuliaLang/julia/issues/38713">https://github.com/JuliaLang/julia/issues/38713</a></li><li><a href="https://github.com/JuliaLang/julia/pull/24990">https://github.com/JuliaLang/julia/pull/24990</a></li></ul><p>There are packages that define anonymous function syntax, and it would be nice to ensure that they compose with e.g. <code>@xquote</code>.</p><ul><li><a href="https://c42f.github.io/Underscores.jl/stable/#Reference-1">https://c42f.github.io/Underscores.jl/stable/#Reference-1</a></li></ul><h1 id="Philosophy"><a class="docs-heading-anchor" href="#Philosophy">Philosophy</a><a id="Philosophy-1"></a><a class="docs-heading-anchor-permalink" href="#Philosophy" title="Permalink"></a></h1><h2 id="Names"><a class="docs-heading-anchor" href="#Names">Names</a><a id="Names-1"></a><a class="docs-heading-anchor-permalink" href="#Names" title="Permalink"></a></h2><p>(see also <a href="https://en.wikipedia.org/wiki/Structural_type_system">nominative and structural type systems</a>)</p><p>The Julia ecosystem goes to great lengths to find the right generic functions and to ensure that all methods defined on generic functions are semantically compatible. This effort enables generic programming and interoperability. Much care goes into naming these functions and deciding their generic meaning, and it makes sense to reuse those names when possible, instead of creating a new name.</p><p>One possible advantage of using compositional names for types is that two packages can declare methods on the same type without knowing about each other, as long as both packages know about the constituents of the composition. There may be situations in which using a compositional name is a better strategy than trying to establish a &quot;FooBase&quot; package.</p><p>It is certainly possible to go overboard, however.</p><h2 id="Type-Piracy"><a class="docs-heading-anchor" href="#Type-Piracy">Type Piracy</a><a id="Type-Piracy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Piracy" title="Permalink"></a></h2><p>The Julia manual discusses <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Don&#39;t-overload-methods-of-base-container-types">not overloading methods on container types</a> defined by others (<a href="https://github.com/JuliaLang/julia/blob/ef3c20d49ad96d5ce1aa24f5d0e0766c64283f28/doc/src/manual/style-guide.md#dont-overload-methods-of-base-container-types">hashed</a>).</p><p>Arguably <a href="@ref"><code>Call</code></a> can be seen as a container type, but the whole purpose of it is for methods to be defined on it. As far as type piracy is concerned, e.g.  <code>@xquoteT ::Int64 / ::Int64</code>  is equivalent to using <code>Rational{Int64}</code> since in both cases, all types are owned by <code>Base</code> (assuming <code>Call</code>, <code>Lambda</code>, etc. is not owned by your package (module) either). In this example, the types are <code>typeof(/)</code> and <code>Int64</code>.</p><p>For a function owned by your package, e.g. <code>my_foo</code>, by all means define <code>my_foo(::(@xquoteT ::Int64 / ::Int64))</code>.</p><p>For a function not owned your package, e.g. <code>Base.:*</code>, to avoid type piracy, <code>*</code> should be defined by a package that owns at least one of the constituent types, e.g.</p><ul><li><code>Base.:*(::(@xquote MyFunction(::NotMyType))</code></li><li><code>Base.:*(::(@xquote NotMyFunction(::MyType))</code></li><li><code>Base.:*(::(@xquote MyFunction(::MyType))</code></li></ul><p>If it is controversial what <code>f(::(@xquoteT func(::A, ::B)</code> should mean, then it is likely worth defining a new type instead of using this package.</p><p>If there are multiple functions that apply to the fields of a struct, as in:</p><pre><code class="language-julia hljs">struct MyType{T1, T2}
    arg1::T1
    arg2::T2
end

f1(t::MyType) = *(t.arg1, t.arg2)
f2(t::MyType) = +(t.arg1, t.arg2)</code></pre><p>Then it also seems like type would also not be a good candidate to be replaced with a <code>Call</code>. Which of <code>*</code> or <code>+</code> would one choose?</p><h1 id="More-examples"><a class="docs-heading-anchor" href="#More-examples">More examples</a><a id="More-examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-examples" title="Permalink"></a></h1><h2 id="Types-of-geometry-primitives-from-scratch"><a class="docs-heading-anchor" href="#Types-of-geometry-primitives-from-scratch">Types of geometry primitives from scratch</a><a id="Types-of-geometry-primitives-from-scratch-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-geometry-primitives-from-scratch" title="Permalink"></a></h2><p>What is better?</p><pre><code class="language-julia hljs">struct Disc{R, C}
    radius::R
    center::C
end</code></pre><p>or</p><pre><code class="language-julia hljs">using LinearAlgebra: norm
Disc(r, c) = @xquote x -&gt; norm(x - c) ≤ r</code></pre><p>Honestly, I don&#39;t know. I imagine there is a trade-off. But consider a situation where you&#39;d like to distinguish between the disc with boundary, disc without boundary, and just the boundary (a circle). Those distinctions are as simple as <code>≤</code>, <code>&lt;</code>, and <code>==</code>. You might more accurately call the struct above <code>DiscWithBoundary</code>, and introduce <code>DiscWithoutBoundary</code> and <code>Circle</code>. Or instead you might use a convention that all the regions are closed sets and introduce wrapper types <code>WithoutBoundary</code> and <code>OnlyBoundary</code>. In both cases, there&#39;s a lot of names to choose...</p><h2 id="A-way-to-avoid-naming-a-new-method"><a class="docs-heading-anchor" href="#A-way-to-avoid-naming-a-new-method">A way to avoid naming a new method</a><a id="A-way-to-avoid-naming-a-new-method-1"></a><a class="docs-heading-anchor-permalink" href="#A-way-to-avoid-naming-a-new-method" title="Permalink"></a></h2><p>Computing the square norm of a vector can usually be done more efficiently than computing the norm and then computing the square.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LinearAlgebra: norm, norm_sqr</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vec = [1, 1]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 1</code></pre><p>instead of writing</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm_sqr(vec)</code><code class="nohighlight hljs ansi" style="display:block;">2.0000000000000004</code></pre><p>maybe you would rather write</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; xeval(@xquote norm(vec)^2::::S)</code><code class="nohighlight hljs ansi" style="display:block;">2.0000000000000004</code></pre><p>Well, perhaps better with an alternative macro that applies <code>::::S</code> to any <code>isbitstype</code> literals, and also does <code>xeval</code>.</p><pre><code class="nohighlight hljs">@a_good_short_name norm(vec)^2</code></pre><p>Whatever owns <code>norm</code> can add a new method to <code>xeval</code> to detect this form and use the more efficient method.</p><pre><code class="language-julia hljs">xeval(c::(@xquoteT norm(::T)^2::::S)) where T = norm_sqr(c.args[1].args[1])</code></pre><p>This is different from having a package define its own macro. This would be one macro that can be hooked into by defining new methods on <code>xeval</code>.</p><h2 id="Alternative-to-Base.literal_pow"><a class="docs-heading-anchor" href="#Alternative-to-Base.literal_pow">Alternative to <code>Base.literal_pow</code></a><a id="Alternative-to-Base.literal_pow-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-to-Base.literal_pow" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Meta.@lower x^2</code><code class="nohighlight hljs ansi" style="display:block;">:($(Expr(:thunk, CodeInfo(
    @ none within `top-level scope`
1 ─ %1 = Core.apply_type(Base.Val, 2)
│   %2 = (%1)()
│   %3 = Base.literal_pow(^, x, %2)
└──      return %3
))))</code></pre><p>Could instead lower to roughly</p><pre><code class="nohighlight hljs">%1 = @xquote x^(2::::S) # i.e. something roughly like `Call(^, x, Val(2))`
%2 = xeval(%1)</code></pre><p><code>xeval</code> could call <code>Base.literal_pow</code> for <a href="https://juliahub.com/ui/CodeSearch?q=literal_pow&amp;u=define&amp;t=all;">backwards compatibility</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FixArgs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function FixArgs.xeval(x::(@xquoteT (::B)^(E::::S))) where {B, E}
           println(&quot;I was called&quot;)
           base = xeval(x.args[1])
           Base.literal_pow(^, base, Val(E))
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let x = 3
           xeval(@xquote x^(2::::S))
       end</code><code class="nohighlight hljs ansi" style="display:block;">I was called
9</code></pre><p>but going forward, types that wish to hook into this functionality would define a method on <code>xeval</code> directly.</p><h2 id="Related-Patterns-and-Possible-Applications:"><a class="docs-heading-anchor" href="#Related-Patterns-and-Possible-Applications:">Related Patterns and Possible Applications:</a><a id="Related-Patterns-and-Possible-Applications:-1"></a><a class="docs-heading-anchor-permalink" href="#Related-Patterns-and-Possible-Applications:" title="Permalink"></a></h2><p><a href="https://github.com/JuliaLang/julia/blob/d06c2a97be3f643d403c4069955e135823ff9fd0/base/broadcast.jl#L152-L173">Base.Broadcast.Broadcasted</a> is like <a href="@ref"><code>Call</code></a> with extra information <code>Style</code> and <code>axes::Axes</code>. <code>materialize</code> is like <code>xeval</code>. There&#39;s more information in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#extending-in-place-broadcast">manual</a>.</p><p><a href="https://github.com/JuliaLang/julia/blob/676ccf4eaa9b6e6c6a53f75abb4bf3e1a2457426/base/generator.jl#L3-L34">Base.Generator</a>, as already discussed.</p><h3 id="partial-application-with-keyword-arguments"><a class="docs-heading-anchor" href="#partial-application-with-keyword-arguments">partial application with keyword arguments</a><a id="partial-application-with-keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#partial-application-with-keyword-arguments" title="Permalink"></a></h3><p><a href="https://github.com/JuliaLang/julia/blob/ce5bd1c3dadcc7c733508a19a4b692b744d59a3d/base/floatfuncs.jl#L288">Definition</a></p><pre><code class="language-julia hljs">isapprox(y; kwargs...) = x -&gt; isapprox(x, y; kwargs...)</code></pre><p>probably would use <code>Base.Fix2</code> if it also supported keyword arguments. All other docstrings with &quot;Create a function&quot; do.</p><h3 id="array-of-struct-and-struct-of-array-representations"><a class="docs-heading-anchor" href="#array-of-struct-and-struct-of-array-representations">array-of-struct and struct-of-array representations</a><a id="array-of-struct-and-struct-of-array-representations-1"></a><a class="docs-heading-anchor-permalink" href="#array-of-struct-and-struct-of-array-representations" title="Permalink"></a></h3><p><a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a></p><pre><code class="language-julia hljs">soa = (a=[1,2,3], b=[10, 20, 30])
aos_eager = map(NamedTuple{(:a, :b)} ∘ tuple, soa.a, soa.b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{NamedTuple{(:a, :b), Tuple{Int64, Int64}}}:
 (a = 1, b = 10)
 (a = 2, b = 20)
 (a = 3, b = 30)</code></pre><h3 id="non-standard-evaluation"><a class="docs-heading-anchor" href="#non-standard-evaluation">non-standard evaluation</a><a id="non-standard-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#non-standard-evaluation" title="Permalink"></a></h3><p><a href="https://discourse.julialang.org/t/approximating-non-standard-evaluation-like-in-r-e-g-for-plot-labels/41889/10">https://discourse.julialang.org/t/approximating-non-standard-evaluation-like-in-r-e-g-for-plot-labels/41889/10</a></p><h3 id="nominal-vs-structural-fields"><a class="docs-heading-anchor" href="#nominal-vs-structural-fields">nominal vs structural fields</a><a id="nominal-vs-structural-fields-1"></a><a class="docs-heading-anchor-permalink" href="#nominal-vs-structural-fields" title="Permalink"></a></h3><p><a href="https://github.com/JuliaLang/julia/pull/37517/files">https://github.com/JuliaLang/julia/pull/37517/files</a> Instead of field names <code>inner</code> and <code>outer</code>, the arguments can be distinguished by the role they play with respect to the function <code>∘</code>.</p><p>What if <code>∘</code> itself is defined as <code>∘(a, b) = @xquote a ∘ b</code>? Then define function without methods: <code>function ∘ end</code></p><h1 id="Concerns"><a class="docs-heading-anchor" href="#Concerns">Concerns</a><a id="Concerns-1"></a><a class="docs-heading-anchor-permalink" href="#Concerns" title="Permalink"></a></h1><p>The poor compiler...</p><p>The poor user trying to understand the error message...</p><p>Method ambiguities</p><p>Unifying too many things can lead to too much coupling.</p><h1 id="API-and-internals"><a class="docs-heading-anchor" href="#API-and-internals">API and internals</a><a id="API-and-internals-1"></a><a class="docs-heading-anchor-permalink" href="#API-and-internals" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FixArgs.ArgPos" href="#FixArgs.ArgPos"><code>FixArgs.ArgPos</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Within the <code>body</code> of a <a href="#FixArgs.Lambda"><code>Lambda</code></a>, represent a formal positional parameter of that<a href="#FixArgs.Lambda"><code>Lambda</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/types.jl#LL20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Arity" href="#FixArgs.Arity"><code>FixArgs.Arity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represent the <a href="https://en.wikipedia.org/wiki/Arity">arity</a> of a <a href="#FixArgs.Lambda"><code>Lambda</code></a>.</p><p>Currently, only represents a fixed number of positional arguments, but may be generalized to include optional and keyword arguments.</p><p><code>P</code> is 0, 1, 2, ... <code>KW</code> is always <code>NoKeywordArguments</code>, and may be extended in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/types.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Call" href="#FixArgs.Call"><code>FixArgs.Call</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A call &quot;f(args...)&quot;. <code>args</code> may represent both positional and keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/types.jl#LL52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Context" href="#FixArgs.Context"><code>FixArgs.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><p>terms are evaluated with respect to a <code>Context</code> A <code>Context</code> is an associations between bound variables and values, and they may be nested (via the <code>parent</code> field).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/eval.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.Lambda" href="#FixArgs.Lambda"><code>FixArgs.Lambda</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A lambda expression &quot;args -&gt; body&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/types.jl#LL44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.ParentScope" href="#FixArgs.ParentScope"><code>FixArgs.ParentScope</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nest <a href="#FixArgs.ArgPos"><code>ArgPos</code></a> in <a href="#FixArgs.ParentScope"><code>ParentScope</code></a>s to represent a reference to the formal parameters of a &quot;parent&quot; function. Forms a unary representation.</p><p>Related: [De Bruijn indices]https://en.wikipedia.org/wiki/De<em>Bruijn</em>index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/types.jl#LL28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.isexpr-Tuple{Expr}" href="#FixArgs.isexpr-Tuple{Expr}"><code>FixArgs.isexpr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isexpr(expr) -&gt; Bool
isexpr(expr, head) -&gt; Bool</code></pre><p>Checks whether given value isa <code>Base.Expr</code> and if further given <code>head</code>, it also checks whether the <code>head</code> matches <code>expr.head</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using ExprParsers
julia&gt; EP.isexpr(:(a = hi))
true
julia&gt; EP.isexpr(12)
false
julia&gt; EP.isexpr(:(f(a) = a), :(=))
true
julia&gt; EP.isexpr(:(f(a) = a), :function)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/expr.jl#LL83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.lc_expr-Tuple{Any}" href="#FixArgs.lc_expr-Tuple{Any}"><code>FixArgs.lc_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert an expression (e.g. an <code>Expr</code>) to a Lambda-Call value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/expr-to-lambda-call.jl#LL2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.normalize_lambda_1_arg-Tuple{Any}" href="#FixArgs.normalize_lambda_1_arg-Tuple{Any}"><code>FixArgs.normalize_lambda_1_arg</code></a> — <span class="docstring-category">Method</span></header><section><div><p>normalize <code>:(x -&gt; body)</code> into  <code>:((x,) -&gt; body</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/parse.jl#LL14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.postwalk-Tuple{Any, Any}" href="#FixArgs.postwalk-Tuple{Any, Any}"><code>FixArgs.postwalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postwalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>after</em> they have been transformed by the walk.</p><p>See also: <a href="#FixArgs.prewalk-Tuple{Any, Any, Any}"><code>prewalk</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/expr.jl#LL5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.prewalk-Tuple{Any, Any, Any}" href="#FixArgs.prewalk-Tuple{Any, Any, Any}"><code>FixArgs.prewalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prewalk(f, expr)</code></pre><p>Applies <code>f</code> to each node in the given expression tree, returning the result. <code>f</code> sees expressions <em>before</em> they have been transformed by the walk, and the walk will be applied to whatever <code>f</code> returns.</p><p>This makes <code>prewalk</code> somewhat prone to infinite loops; you probably want to try <a href="#FixArgs.postwalk-Tuple{Any, Any}"><code>postwalk</code></a> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/expr.jl#LL17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.relabel_args" href="#FixArgs.relabel_args"><code>FixArgs.relabel_args</code></a> — <span class="docstring-category">Function</span></header><section><div><p>α-conversion in λ-calculus</p><p><code>labeler(x)</code> produces a <code>Symbol</code> or similar from <code>x.referent_depth</code> <code>x.antecedent_depth</code> <code>x.arg_i</code> <code>x.sym</code> – name before relabeling</p><p><code>x.referent_depth - x.antecedent_depth</code> is number of <code>-&gt;</code>s that are between the evaluation site and the definition site</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/parse.jl#LL53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.uneval-Tuple{Expr}" href="#FixArgs.uneval-Tuple{Expr}"><code>FixArgs.uneval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a value, produce an expression that when <code>eval</code>&#39;d produces the value.</p><p>e.g.</p><pre><code class="language-julia hljs">julia&gt; eval(uneval(Expr(:my_call, :arg1, :arg2)))
:($(Expr(:my_call, :arg1, :arg2)))

julia&gt; eval(eval(uneval(:(sqrt(9)))))
3.0</code></pre><p>This function is used to return expressions from this package&#39;s macros. This is likely not a well-posed problem to begin with. <a href="https://github.com/JuliaLang/julia/issues/33260">Related issue.</a></p><p>Note the special case for <code>:(esc(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/uneval.jl#LL1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.xapply" href="#FixArgs.xapply"><code>FixArgs.xapply</code></a> — <span class="docstring-category">Function</span></header><section><div><p>apply a <a href="#FixArgs.Lambda"><code>Lambda</code></a> expression to arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/eval.jl#LL106-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.xeval-Tuple{FixArgs.Call}" href="#FixArgs.xeval-Tuple{FixArgs.Call}"><code>FixArgs.xeval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate a Lambda-Call expression</p><p>Currently only works on <a href="#FixArgs.Call"><code>Call</code></a> expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/eval.jl#LL89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@fix-Tuple{Any}" href="#FixArgs.@fix-Tuple{Any}"><code>FixArgs.@fix</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>A convenience macro that implements the syntax of <a href="https://github.com/JuliaLang/julia/pull/24990">this PR</a></p><p><code>@fix f(_, b)</code> is the equivalent of <code>x -&gt; f(x, b)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/ergonomics.jl#LL249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@quote_some-Tuple{Any}" href="#FixArgs.@quote_some-Tuple{Any}"><code>FixArgs.@quote_some</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>This macro is used to debug and introspect the escaping behavior of <a href="#FixArgs.@xquote-Tuple{Any}"><code>@xquote</code></a></p><pre><code class="language-julia hljs">julia&gt; dump(let x = 9
       @xquote sqrt(x)
       end)
Expr
    head: Symbol call
    args: Array{Any}((2,))
        1: sqrt (function of type typeof(sqrt))
        2: Int64 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/ergonomics.jl#LL144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@xquote-Tuple{Any}" href="#FixArgs.@xquote-Tuple{Any}"><code>FixArgs.@xquote</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Transform julia syntax into a <a href="#FixArgs.Lambda"><code>Lambda</code></a>-<a href="#FixArgs.Call"><code>Call</code></a> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/ergonomics.jl#LL180-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FixArgs.@xquoteT-Tuple{Any}" href="#FixArgs.@xquoteT-Tuple{Any}"><code>FixArgs.@xquoteT</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>The types produced by this package are unwieldly. This macro permits a convenient syntax, e.g. <code>@xquoteT func(::Arg1Type, ::Arg2Type)</code> to represent types.</p><pre><code class="language-julia hljs">let func = identity, arg = 1
    typeof(@xquote func(arg)) == @xquoteT func(::typeof(arg))
end

# output

true</code></pre><p>If an argument is &quot;static&quot;, then it is part of the type, and the value is annotated as illustrated:</p><pre><code class="language-julia hljs">julia&gt; @xquoteT string(123::::S)
FixArgs.Call{Some{typeof(string)},FrankenTuples.FrankenTuple{Tuple{Val{123}},(),Tuple{}}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/goretkin/FixArgs.jl/blob/7e9ab044df960fc5bcf9316e8de93215fd94e92b/src/ergonomics.jl#LL277-L298">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 29 June 2022 19:11">Wednesday 29 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
